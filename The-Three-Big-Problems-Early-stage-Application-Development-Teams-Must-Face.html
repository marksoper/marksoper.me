<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
    <head> 
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 
        <title>Three Unexpected Enginering Problems Startup Teams Face - Mark Soper's Blog</title>

        <link rel="canonical" />
        <link rel="stylesheet" type="text/css" href="site.css" />
        <link rel="stylesheet" type="text/css" href="blog.css" /> 
  
<script src="site.js"></script>

    </head> 
    <body> 
        
     <div class="header">
      
      <div class="title">
        <a href="./" title="Mark Soper">
          <h1>Mark Soper
            <br>
            <span class="profession">
              Javascript Developer
            </span>
            <br>
            <span class="location">
              Cambridge, MA
            </span>
          </h1>
        </a>
      </div>

      <div class="nav">
        <ul>

          <li>
            <a href="./#contact" title="Contact Mark Soper">
              Contact
            </a>
          </li>

          <li>
            <a href="./#blog" title="Mark Soper's Blog">
              Blog
            </a>
          </li>

          <li>
            <a href="./#projects" title="Mark Soper's Projects">
              Projects
            </a>
          </li>

        </ul>
      </div>

    </div>


        <div class="container">


                          <div class="articleHeader">
    <div class="articleTitle">
                  <h1>Three Unexpected Enginering Problems Startup Teams Face</h1>
    </div>

    <div class="articleDate">
                  <div class="articleWeekday">
                    Tuesday
                  </div>
                  <div class="articleDay">
                    June 16
                  </div>
                  <div class="articleYear">,
                    2015
                  </div>
    </div>
        </div>
             

<p>
  Coming up for air after a few years of early-stage application development projects, I've gathered here some accrued thoughts on the most unexpected, difficult, and otherwise interesting problems that have arisen despite the best intentions of experienced and talented teams.
</p>

<h2>
  1. The Unimportant Decision Problem
</h2>

<div class="topicHeader">
  <p>
    <b>Problem: </b>
    <em>Too much effort invested in making decisions when a decent arbitary choice (from already-available options that satisfy the fundamental requirement) is just as good or better than the options you're considering.</em>
    <br><br>
    <b>Solution: </b><br>
      <em>
        1. Be aggressive about distinguishing important problems from unimportant problems.<br>
        2. Put in provisional implementations instead of going for perfection right away.<br>
        3. Decide up front on existing libraries, frameworks, style guides, etc. that will provide a standard set of solutions to these problems.<br>
        4. Enforce that the team use these standard solutions!<br>
      </em>
  </p>
</div>

<p>
  Many teams pursue the MVP concept: remove superfluous features until the product is minimally viable. Within the context of each feature, however, teams often do not apply this kind of focus.
</p>

<h3>Non-differentiative (but Required) Components</h3>

<p>
 Consider User Settings, a major UI component that's required but doesn't really differentiate the product. Teams may invest heavily in custom design and engineering when there's little chance of meaningful UX improvement and high likelihood of a non-standard approach to some form input causing user frustration.
</p>

<div class="comingSoon">
  <b>Coming soon: </b>
  <em>An article exploring how basic UI for features like User Settings can be generated from fundamental specifications like a User model schema definition.</em>
</div>

<h3>Non-differentiative details of Differentiative Components</h3>

<p>
  Even when dealing with critical major components that truly differentiate the product, non-critical design and implementation decisions get fretted over, debated, implemented and re-implemented before anyone ever really uses it.
</p>

<p>
  Your chat app is going to be the next big thing because of its advanced message search capabilities. A good search UX is critical. But does this UX need to be innovative? Does it require creative rethinking of existing search UI patterns? Maybe your special sauce is the advanced AI your PhD's are developing, functionality that's completely decoupled from the front-end. Can get by with your framework's stock autocomplete input for now instead of rolling your own?
</p>

<h3>Variations for Page Layout and Navigation</h3>

<p>
  How to arrange components onto pages and how to navigate between them is a major area for counter-productive debate and fretting over decisions. And the problem gets compounded by the multi-platform problem discussed below as you're often trying to hit multiple moving UI design targets (e.g. smartphone and desktop) simultaneously. Usually here are only handful of reasonable layout/navigation arrangements worth considering - e.g. "Throw everything on one page (great for desktop!)" or "Every component on its own page with a navbar at bottom (great for smartphone)". Usually it's not possible to know what the best choices are. You might implement it one way, user test it, and then realize there's a better way to organize.
</p>

<p>

</p>

<div class="comingSoon">
  <b>Coming soon: </b> More on how to get layout/nav right across different devices. We need low-level layout and navigation primitives that express fundamental product behavior and use a layout/nav engine to generate different variations that can be evaluated and tested in different environments. Think responsive design but at a much deeper level in the UI architecture.
</div>

<h2>
  2. The Multi-Platform Problem
</h2>

<div class="topicHeader">
  <p>
    <b>Problem: </b>
    <em>The end user UI environment is increasingly fragmented and unpredictible. There's pressure on startups to provide a great product across many device/platform/screen-size configurations, and this is a near-impossible cahllenge for teams with limited resources.</em>
    <br><br>
    <b>Solution: </b>
    <em>
      Focus relentlessly on core, platform-agnostic issues. Defer supporting mutliple environments if possible. Shift programming work away from the front-end, and use technologies that make it easier to do this.
    </em>
  </p>
</div>

<p>
  It's no surprise that building for multiple device platforms, device types, and screen-sizes is a huge UI engineering challenge. What's impressed over the years as a long-time web developer is the extent to which it's a deep problem with critical system design implications everywhere in the product and huge strategic implications for the business. There's more on the magnitude of this problem HERE (link). Instead let's focus on the solution.
</p>

<h3>
  Make Parallel Development Projects Less Redundant
</h3>

<p>
  The last thing an entrepreneurial team needs is to be caught up in redundant parallel development tracks building for myriad UI environments (web, iOS, Android, email, smartphone, tablet, etc.), trying to hit multiple moving targets at the same time while ensuring UX consistency, observing DRY, and reconciling worthwhile domain learning across multiple development teams/projects. 
</p>

<p>
  It's important for early-stage projects to be relentless about focusing on core engineering challenges. Depending on the situation, this may mean starting iOS-only or web-only. It might mean using a hybrid approach - e.g. one of several based on Apache Cordova - where native apps are generated from the same HTML/JS/CSS code used in the web app. The consensus seems to be that hybrid development isn't an attractive long-term approach, but for some types of apps it can be a good early-stage choice in lieu of the eventual switch to a UI built from native components. We need better technology to solve the problem, and I'm optimistic we'll see it in the near future.
</p>

<h3>
  Push Computing Lower in the Stack
</h3>

<p>
  The innovative approach taken by React Native - share (Javascript) front-end data management code across platforms and write simple, native platform-specific code at the view layer - offers a pointer into what the future may hold. The key insight here is that in a multi-platform system, we should relentlessly push computing into lower levels of the stack below the "platform-agnostic threshold" and favor technologies like React Native that move that threshold out toward the UI. 
</p>

<p>
  As a general rule, when deciding what to do or not to do in an early-stage project, favor initiatives that focus on core, domain-specific engineering.  Does it help move you closer toward understanding the fundamental and unique data model and user interactions that will eventually power your successful product regardless of what device the user's holding? If not, try to avoid it!
</p>

<h2>
  3. The Multiple Designs Problem
</h2>

<div class="topicHeader">
  <p>
    <b>Problem: </b>
    <em>What's referred to as <b>design</b> in web/mobile application development only gives you half of the development plan your team needs to be successful.</em>
    <br><br>
    <b>Solution: </b>
    <em>
      Product owner, UI/UX Designer, and Front-end Engineer should work together intimately from the beginning to "do design" for the project. Include modularity, data-flow, and systemic events as first class design considerations alongside traditional UI/UX design issues.
    </em>
  </p>
</div>

  <p>
    <em><b>UI/UX design</b> and <b>Software design of UI software</b> are two different things.</em>
  </p>

  <ul>
    <li>
      <b>UI/UX design</b> - typically done by a professional designer, this involves working with the product's business owner to get the product vision out of his/her head and into a <b>visual representation (wirefreames, mocks, etc) of the user experience (UX) and associated user interface (UI)</b>.
    </li>
    <br>
    <li>
      <b>Software design of UI software</b> - typically done by a professional (front-end) software engineer, this involves creating a <b>plan for program(s) that the team will be building, with modularity and managing the flow of data</b> as the key considerations. See Leslie Lamport's excellent work on getting the message out about the importance of "blueprints" before jumping into coding.
    </li>
  </ul>

  <p>
    Most teams focus on the former and neglect that latter. The mocks stand in as software design. In the worst case scenarios the team jumps into coding up the mocks without thinking about software design. In a better but still wrong scenario, the engineering team <em>derives a software design</em> from the mocks - something like "drawing a bunch of nested rectangles on these mocks I see we're going to need the following 24 UI components and our model layer will need to have these 8 models ...
  </p>

  <p>
    The right way to do this is to have someone (the UI engineer) engaged in software design from the very beginning, working in parallel with a designer who's focused on UX, and the product owner who has the vision. A lot more collaboration is required up front, but doing this right means you have just created an <b><em>application design</em></b> that encompasses both UI/UX and software design. Critical considerations like modularity, thinking holistically about all of the meaningful events that can occur in a system, and how data will flow across the entire system play a first class role alongside equally important considerations like aesthetic, look-and-feel, usability, and good UI design patterns.
  </p>

  <p>
    A good way to compensate for the the extra collaborative cost incurred is to constrain the scope of both design disciplines. Defer "unimportant decisions" whenever possible. Don't worry about pixel-perfection. Typography, colors, and other style guide issues can probably wait. In terms of software design, keep it very low level, thinking about the core data model that this thing will run on, and the fundamental user actions and other events that are meaningful to the product. Let these two design disciplines evolve in parallel toward less fundamental issues like componentizing the UI, layout/nav decisions, and determining the right UI patterns to use. 
  </p>

  <div class="comingSoon">
    <em>Coming Soon: </em> An article with more detail and examples about this <b><em>application design</em></b> approach.
  </div>




      <div id="disqus_thread"></div>

<script>
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'marksopersblog'; // required: replace example with your forum shortname

// The following are highly recommended additional parameters. Remove the slashes in front to use.
var disqus_identifier = window.location.href;
var disqus_url = window.location.href;

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

        </div>
        
    </body>
</html>
