
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>GraphQL and Data Fluency for the Entire Product Team</title>

        <link rel="canonical" />

<style type="text/css">ul.lst-kix_jubgn4b2ml5y-0{list-style-type:none}.lst-kix_jubgn4b2ml5y-6>li:before{content:"\0025cf  "}ul.lst-kix_jubgn4b2ml5y-1{list-style-type:none}ul.lst-kix_jubgn4b2ml5y-2{list-style-type:none}.lst-kix_jubgn4b2ml5y-7>li:before{content:"\0025cb  "}ul.lst-kix_jubgn4b2ml5y-3{list-style-type:none}ul.lst-kix_jubgn4b2ml5y-4{list-style-type:none}.lst-kix_jubgn4b2ml5y-8>li:before{content:"\0025a0  "}.lst-kix_jubgn4b2ml5y-4>li:before{content:"\0025cb  "}.lst-kix_jubgn4b2ml5y-5>li:before{content:"\0025a0  "}ul.lst-kix_jubgn4b2ml5y-5{list-style-type:none}ul.lst-kix_jubgn4b2ml5y-6{list-style-type:none}ul.lst-kix_jubgn4b2ml5y-7{list-style-type:none}.lst-kix_jubgn4b2ml5y-2>li:before{content:"\0025a0  "}.lst-kix_jubgn4b2ml5y-3>li:before{content:"\0025cf  "}.lst-kix_jubgn4b2ml5y-0>li:before{content:"\0025cf  "}.lst-kix_jubgn4b2ml5y-1>li:before{content:"\0025cb  "}ul.lst-kix_jubgn4b2ml5y-8{list-style-type:none}ol{margin:0;padding:0}.c9{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c1{orphans:2;widows:2;direction:ltr}.c2{color:inherit;text-decoration:inherit}.c8{padding:0;margin:0}.c5{color:#1155cc;text-decoration:underline}.c6{margin-left:36pt;padding-left:0pt}.c7{font-weight:bold}.c0{font-style:italic}.c3{height:11pt}.c4{page-break-after:avoid}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style>

        <link rel="stylesheet" type="text/css" href="site.css" />
        <link rel="stylesheet" type="text/css" href="blog.css" />

<script src="site.js"></script>

    </head>
    <body>

     <div class="header">

      <div class="title">
        <a href="./" title="Mark Soper">
          <div class="header-h2">Mark Soper
            <br>
            <span class="profession">
              Software Engineer
            </span>
            <br>
            <span class="location">
              Cambridge, MA
            </span>
          </div>
        </a>
      </div>

      <div class="nav">
        <ul>

          <li>
            <a href="./#contact" title="Contact Mark Soper">
              Contact
            </a>
          </li>

          <li>
            <a href="./#blog" title="Mark Soper's Blog">
              Blog
            </a>
          </li>

          <li>
            <a href="./#projects" title="Mark Soper's Projects">
              Projects
            </a>
          </li>

        </ul>
      </div>

    </div>


        <div class="container">


                          <div class="articleHeader">
    <div class="articleTitle">
                  <h1>GraphQL and Data Fluency for the Entire Product Team</h1>
    </div>

    <div class="articleDate">
                  <div class="articleWeekday">
                    Wednesday
                  </div>
                  <div class="articleDay">
                    Jan 20
                  </div>
                  <div class="articleYear">,
                    2016
                  </div>
    </div>
        </div>

<p>
  As a freelance software engineer I've had the opportunity to work with many early-stage teams over the past few years.
  I've become especially interested in the overall collaboration among these teams:
  product owners, designers, engineers, QA, analysts, etc.
  I'm convinced that how the entire team works together is critically important to the success of the product.
  I'm also convinced that there's a growing need for improvement in the process and tools teams use to collaborate, especially
  with respect to a shared understanding of the fundamental design specification. We need a way for everyone to reason about how the
  product is supposed to work.
</p>

<p>
  I think we in the engineering community already get this. We hear the term "easier to reason about" used constantly to
  explain major trends (e.g. functional programming) and technologies (e.g. React.js) whose popularity has exploded in recent years.
  Collectively we've realized the cost of incidental complexity and are taking steps to fight it.
  But I question whether everyone else involved in software products is benefitting from these anti-complexity efforts.
  Is it any easier for a designer or product manager to "reason about" a web app made with React than one made with Angular or whatever?
</p>

<p>
  We in the engineering profession can and should do a better job of communicating and making available our anti-complexity
  advancements more broadly to the business interests we serve and the everyone else involved the product lifecycle.
  I believe that the best way to do this is to pursue technology and process improvements
  that increase <em>data fluency</em> within teams and companies. Long gone are the days when
  data models were an implementation detail closely guarded by a few engineers and DBAs in a basement office.
  Increasingly everyone on the team and everyone in the company must be able to understand and manage the data
  that powers the product and ultimately, the business.
</p>

<h2>
  GraphQL as a platform for data fluency
</h2>

<p>
  Expanding data fluency beyond engineering requires a more declarative,
  comprehensive approach to describing and processing data, a way to work with the DNA of a system that's
  approachable without programming experience.
  In 2015 Facebook made available <a href="https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html" title="GraphQL">GraphQL</a>,
  a technology with promising implications for developing such an approach.
  I believe GraphQL is promising because it provides a expressive <em>type system</em> that's not tied to any programming language
  or DBMS. It's well suited to maintaining a central data model that works with various front-end languages, in any back-end language
  environment, and with data from multiple disparate databases. GraphQL also supports queries, expressions of specific combinations of data
  associated with a UI feature. The type system is a declarative way to describe the shape of data system-wide, and the query language represents a
  declarative way to describe the shape of user interfaces to that data. Together these two aspects make GraphQL a promising as a foundation
  for data fluency.
</p>
<p>
  In addition to learning more about and contributing to existing efforts in the GraphQL ecosystem,
  I'm researching several specific areas where I believe GraphQL will begin to improve data fluency among entire product teams.
</p>

<h2>
  Making data schema accessible to entire teams
</h2>

<p>
  The GraphQL type system involves managing a schema of data types (e.g. User, Product, Transaction) in terms of their properties
  (User has name, email, etc.) and relationships (e.g. Transaction involves multiple Products). These definitions are implemented
  as code in whatever server-side programming language the team chooses. Using the building blocks the schema provides, programmers
  create feature-specific <em>queries</em> for retrieving data and <em>mutations</em> for updating data.
</p>
<p>

<p>
  The engineering team should own the schema design process because it forms the foundation for the rest of the code in the product.
  But the schema is also the DNA of the user experience with profound implications on how people use the product. In my experience,
  there's a lack of awareness of this among product owners and UI/UX designers with a premature emphasis on pixels leading to a disconnect
  between visual design and the actual system design (i.e. a comprehensive development plan) for the product.
</p>

<p>
  I believe the whole team can benefit from understanding how information is organized in the product, and that many product owners
  see this benefit. But good tools and processes to support this aren't yet available. GraphQL is conducive to graphical
  UIs that can help non-programmers understand and in some cases manage the evolving data model. Facebook developed a primitive graphical IDE
  called <a href="https://github.com/graphql/graphiql">GraphiQL</a> for programmers that could form the basis or inspiration for
  a more advanced interface that moves the whole team closer to being able to "reason about" the product.
</p>

<h2>
  Admin UIs with which entire teams can manage system data
</h2>

<p>
  In addition to understanding the shape of the data, broadening groups of people need direct real-time access to the data itself
  in a variety of ways, ranging from populating test data in the early stages to analyzing and measuring the product in production.
  GraphQL's UI-specific queries and introspection capability, a way to query the schema on the fly to learn how data can be accessed,
  create potential for more product-oriented administration interfaces that improve upon the scaffolding-based admin functionality common to web frameworks like
  Rails and Django.
</p>
<p>
  There's also interesting potential to improve analytics available to the entire team. Too often analytics and measurement
  are accomplished as an afterthought. With the ship data rapidly approaching, a hasty effort is made to instrument the product
  and implement schema, storage, and reporting as a separate system from the product itself. I believe analytics should emerge more
  naturally from the product itself, and am eager to explore how GraphQL's type-system orientation might lend itself to this goal.
</p>

<p>
  If any of these ideas resonate, please get in touch <a href="http://twitter.com/marksoper">@marksoper</a>.

      <div id="disqus_thread"></div>

<script>
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'marksopersblog'; // required: replace example with your forum shortname

// The following are highly recommended additional parameters. Remove the slashes in front to use.
var disqus_identifier = window.location.href;
var disqus_url = window.location.href;

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

        </div>

    </body>
</html>
